{"ast":null,"code":"import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n        if (canContinue) {\n          continueResolve(value);\n        }\n        return canContinue;\n      };\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\nexport { CancelledError, canFetch, createRetryer, isCancelledError };","map":{"version":3,"names":["focusManager","onlineManager","sleep","defaultRetryDelay","failureCount","Math","min","canFetch","networkMode","isOnline","CancelledError","constructor","options","revert","silent","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","Promise","outerResolve","outerReject","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","shouldPause","isFocused","resolve","onSuccess","onError","pause","continueResolve","canContinue","onPause","then","undefined","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","continue","didContinue"],"sources":["C:/Users/gregor.woiwode/workbench/talks/talk-qwik-angular/node_modules/.pnpm/@tanstack+query-core@4.32.0/node_modules/@tanstack/query-core/build/lib/retryer.mjs"],"sourcesContent":["import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n\n        if (canContinue) {\n          continueResolve(value);\n        }\n\n        return canContinue;\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}