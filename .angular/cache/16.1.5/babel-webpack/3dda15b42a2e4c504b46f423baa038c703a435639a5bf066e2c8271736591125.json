{"ast":null,"code":"import { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  setOptions(options) {\n    this.options = {\n      ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    var _this$retryer;\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    var _this$retryer2;\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n  onOnline() {\n    var _this$retryer3;\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n          return undefined;\n        }\n      });\n    };\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\"Missing queryFn for queryKey '\" + this.options.queryHash + \"'\");\n      }\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n          }\n          onError(new Error(this.queryHash + \" data is undefined\"));\n          return;\n        }\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused'\n          };\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching'\n          };\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n        case 'error':\n          const error = action.error;\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return {\n              ...this.revertState\n            };\n          }\n          return {\n            ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case 'setState':\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\nexport { Query };","map":{"version":3,"names":["replaceData","noop","timeUntilStale","getAbortController","defaultLogger","notifyManager","createRetryer","isCancelledError","canFetch","Removable","Query","constructor","config","abortSignalConsumed","defaultOptions","setOptions","options","observers","cache","logger","queryKey","queryHash","initialState","state","getDefaultState","scheduleGc","meta","updateCacheTime","cacheTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","dispatch","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","_this$retryer","promise","retryer","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","onFocus","_this$retryer2","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","_this$retryer3","shouldFetchOnReconnect","addObserver","includes","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","continueRetry","queryFn","Array","isArray","process","env","NODE_ENV","error","abortController","queryFnContext","pageParam","undefined","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","reject","context","behavior","onFetch","revertState","fetchMeta","_context$fetchOptions2","onError","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","call","onSettled","isFetchingOptimistic","fn","abort","bind","onSuccess","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","Error","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","action","reducer","_action$meta","_action$dataUpdatedAt","fetchFailureCount","fetchFailureReason","status","dataUpdateCount","Date","now","errorUpdateCount","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"sources":["C:/Users/gregor.woiwode/workbench/talks/talk-qwik-angular/node_modules/.pnpm/@tanstack+query-core@4.32.0/node_modules/@tanstack/query-core/build/lib/query.mjs"],"sourcesContent":["import { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\"Missing queryFn for queryKey '\" + this.options.queryHash + \"'\");\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n          }\n\n          onError(new Error(this.queryHash + \" data is undefined\"));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}