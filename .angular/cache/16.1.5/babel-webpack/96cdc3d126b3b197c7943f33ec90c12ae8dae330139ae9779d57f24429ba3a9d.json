{"ast":null,"code":"import { DataSource } from '@angular/cdk/collections';\nimport { map } from 'rxjs/operators';\nimport { merge, of as observableOf } from 'rxjs';\n/**\n * Data source for the Table view. This class should\n * encapsulate all logic for fetching and manipulating the displayed data\n * (including sorting, pagination, and filtering).\n */\nexport class TableDatasource extends DataSource {\n  constructor(data) {\n    super();\n    this.data = data;\n  }\n  /**\n   * Connect this data source to the table. The table will only update when\n   * the returned stream emits new items.\n   * @returns A stream of the items to be rendered.\n   */\n  connect() {\n    const data$ = observableOf(this.data);\n    if (this.paginator && this.sort) {\n      // Combine everything that affects the rendered data into one update\n      // stream for the data-table to consume.\n      return merge(data$, this.paginator.page, this.sort.sortChange).pipe(map(() => {\n        return this.getPagedData(this.getSortedData([...this.data]));\n      }));\n    }\n    return data$;\n  }\n  /**\n   *  Called when the table is being destroyed. Use this function, to clean up\n   * any open connections or free any held resources that were set up during connect.\n   */\n  disconnect() {\n    /* left blank */\n  }\n  /**\n   * Paginate the data (client-side). If you're using server-side pagination,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  getPagedData(data) {\n    if (this.paginator) {\n      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n      return data.splice(startIndex, this.paginator.pageSize);\n    } else {\n      return data;\n    }\n  }\n  /**\n   * Sort the data (client-side). If you're using server-side sorting,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  getSortedData(data) {\n    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n      return data;\n    }\n    return data.sort((a, b) => {\n      if (!isRecord(a)) return 0;\n      if (!isRecord(b)) return 0;\n      const isAsc = this.sort?.direction === 'asc';\n      // Extracting as much information of the model as possible in order to provide\n      // automatic sorting capabilities\n      // const model = this.data[0];\n      const modelProperties = Object.keys(a);\n      const sortingKey = this.sort?.active || '';\n      const isSortingKeyMatchingAModelProperty = modelProperties.includes(sortingKey);\n      if (!isSortingKeyMatchingAModelProperty) return 0;\n      const actual = a[sortingKey];\n      const comparing = b[sortingKey];\n      if (typeof actual === 'string' && typeof comparing === 'string') return compare(actual, comparing, isAsc);\n      if (typeof actual === 'number' && typeof comparing === 'number') return compare(actual, comparing, isAsc);\n      return 0;\n    });\n  }\n}\n/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\nfunction compare(a, b, isAsc) {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}\nfunction isRecord(candidate) {\n  return !!candidate || typeof candidate === 'object';\n}","map":{"version":3,"names":["DataSource","map","merge","of","observableOf","TableDatasource","constructor","data","connect","data$","paginator","sort","page","sortChange","pipe","getPagedData","getSortedData","disconnect","startIndex","pageIndex","pageSize","splice","active","direction","a","b","isRecord","isAsc","modelProperties","Object","keys","sortingKey","isSortingKeyMatchingAModelProperty","includes","actual","comparing","compare","candidate"],"sources":["C:\\Users\\gregor.woiwode\\workbench\\talks\\talk-qwik-angular\\apps\\insurance-angular\\src\\app\\components\\table\\table.datasource.ts"],"sourcesContent":["import { DataSource } from '@angular/cdk/collections';\nimport { MatPaginator } from '@angular/material/paginator';\nimport { MatSort } from '@angular/material/sort';\nimport { map } from 'rxjs/operators';\nimport { merge, Observable, of as observableOf } from 'rxjs';\n\n/**\n * Data source for the Table view. This class should\n * encapsulate all logic for fetching and manipulating the displayed data\n * (including sorting, pagination, and filtering).\n */\nexport class TableDatasource<TModel> extends DataSource<TModel> {\n  paginator: MatPaginator | undefined;\n  sort: MatSort | undefined;\n\n  constructor(public readonly data: TModel[]) {\n    super();\n  }\n\n  /**\n   * Connect this data source to the table. The table will only update when\n   * the returned stream emits new items.\n   * @returns A stream of the items to be rendered.\n   */\n  connect(): Observable<TModel[]> {\n    const data$ = observableOf(this.data);\n\n    if (this.paginator && this.sort) {\n      // Combine everything that affects the rendered data into one update\n      // stream for the data-table to consume.\n      return merge(data$, this.paginator.page, this.sort.sortChange).pipe(\n        map(() => {\n          return this.getPagedData(this.getSortedData([...this.data]));\n        })\n      );\n    }\n    return data$;\n  }\n\n  /**\n   *  Called when the table is being destroyed. Use this function, to clean up\n   * any open connections or free any held resources that were set up during connect.\n   */\n  disconnect(): void {\n    /* left blank */\n  }\n\n  /**\n   * Paginate the data (client-side). If you're using server-side pagination,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  private getPagedData(data: TModel[]): TModel[] {\n    if (this.paginator) {\n      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n      return data.splice(startIndex, this.paginator.pageSize);\n    } else {\n      return data;\n    }\n  }\n\n  /**\n   * Sort the data (client-side). If you're using server-side sorting,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  private getSortedData(data: TModel[]): TModel[] {\n    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n      return data;\n    }\n\n    return data.sort((a, b) => {\n      if (!isRecord(a)) return 0;\n      if (!isRecord(b)) return 0;\n\n      const isAsc = this.sort?.direction === 'asc';\n\n      // Extracting as much information of the model as possible in order to provide\n      // automatic sorting capabilities\n      // const model = this.data[0];\n      const modelProperties = Object.keys(a);\n\n      const sortingKey = this.sort?.active || '';\n      const isSortingKeyMatchingAModelProperty = modelProperties.includes(sortingKey);\n\n      if (!isSortingKeyMatchingAModelProperty) return 0;\n\n      const actual = a[sortingKey];\n      const comparing = b[sortingKey];\n\n      if (typeof actual === 'string' && typeof comparing === 'string')\n        return compare(actual, comparing, isAsc);\n\n      if (typeof actual === 'number' && typeof comparing === 'number')\n        return compare(actual, comparing, isAsc);\n\n      return 0;\n    });\n  }\n}\n\n/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\nfunction compare(a: string | number, b: string | number, isAsc: boolean): number {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}\n\nfunction isRecord(candidate: unknown): candidate is Record<string, unknown> {\n  return !!candidate || typeof candidate === 'object';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}