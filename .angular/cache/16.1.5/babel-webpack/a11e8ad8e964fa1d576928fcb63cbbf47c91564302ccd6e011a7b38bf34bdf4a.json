{"ast":null,"code":"import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n  getAll() {\n    return this.mutations;\n  }\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    var _this$resuming;\n    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {\n      const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.resuming = undefined;\n    });\n    return this.resuming;\n  }\n}\nexport { MutationCache };","map":{"version":3,"names":["notifyManager","Mutation","matchMutation","noop","Subscribable","MutationCache","constructor","config","mutations","mutationId","build","client","options","state","mutation","mutationCache","logger","getLogger","defaultMutationOptions","defaultOptions","mutationKey","getMutationDefaults","undefined","add","push","notify","type","remove","filter","x","clear","batch","forEach","getAll","find","filters","exact","findAll","event","listeners","listener","resumePausedMutations","_this$resuming","resuming","Promise","resolve","then","pausedMutations","isPaused","reduce","promise","continue","catch"],"sources":["C:/Users/gregor.woiwode/workbench/talks/talk-qwik-angular/node_modules/.pnpm/@tanstack+query-core@4.32.0/node_modules/@tanstack/query-core/build/lib/mutationCache.mjs"],"sourcesContent":["import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    var _this$resuming;\n\n    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {\n      const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.resuming = undefined;\n    });\n    return this.resuming;\n  }\n\n}\n\nexport { MutationCache };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}