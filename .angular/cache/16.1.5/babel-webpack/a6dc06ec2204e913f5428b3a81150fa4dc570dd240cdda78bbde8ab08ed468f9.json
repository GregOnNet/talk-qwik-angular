{"ast":null,"code":"import { difference, replaceAt } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n  destroy() {\n    this.listeners = new Set();\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n      if (!this.hasListeners()) {\n        return;\n      }\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n  getCurrentResult() {\n    return this.result;\n  }\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n  getObservers() {\n    return this.observers;\n  }\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n    const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(this.result);\n      });\n    });\n  }\n}\nexport { QueriesObserver };","map":{"version":3,"names":["difference","replaceAt","notifyManager","QueryObserver","Subscribable","QueriesObserver","constructor","client","queries","result","observers","observersMap","setQueries","onSubscribe","listeners","size","forEach","observer","subscribe","onUpdate","onUnsubscribe","destroy","Set","notifyOptions","batch","prevObservers","newObserverMatches","findMatchingObservers","match","setOptions","defaultedQueryOptions","newObservers","map","newObserversMap","Object","fromEntries","options","queryHash","newResult","getCurrentResult","hasIndexChange","some","index","length","hasListeners","notify","getQueries","getCurrentQuery","getObservers","getOptimisticResult","prevObserversMap","Map","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","get","matchedQueryHashes","unmatchedQueries","filter","has","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","keepPreviousData","previouslyUsedObserver","undefined","sortMatchesByOrderOfQueries","a","b","indexOf","concat","sort","listener"],"sources":["C:/Users/gregor.woiwode/workbench/talks/talk-qwik-angular/node_modules/.pnpm/@tanstack+query-core@4.32.0/node_modules/@tanstack/query-core/build/lib/queriesObserver.mjs"],"sourcesContent":["import { difference, replaceAt } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.observers;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n    const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nexport { QueriesObserver };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}