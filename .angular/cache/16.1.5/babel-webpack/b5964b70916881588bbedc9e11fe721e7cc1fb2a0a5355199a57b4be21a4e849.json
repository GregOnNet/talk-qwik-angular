{"ast":null,"code":"// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n  if (typeof arg2 === 'function') {\n    return {\n      ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n  return {\n    ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return {\n        ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n    return {\n      ...arg2,\n      mutationKey: arg1\n    };\n  }\n  if (typeof arg1 === 'function') {\n    return {\n      ...arg2,\n      mutationFn: arg1\n    };\n  }\n  return {\n    ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{\n    ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{\n    ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== 'all') {\n    const isActive = query.isActive();\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n  const ctor = o.constructor;\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };","map":{"version":3,"names":["isServer","window","noop","undefined","functionalUpdate","updater","input","isValidTimeout","value","Infinity","difference","array1","array2","filter","x","includes","replaceAt","array","index","copy","slice","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","isPlainArray","aSize","length","bItems","bSize","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","isError","Error","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","getAbortController","AbortController","replaceData","prevData","data","isDataEqual","structuralSharing"],"sources":["C:/Users/gregor.woiwode/workbench/talks/talk-qwik-angular/node_modules/.pnpm/@tanstack+query-core@4.32.0/node_modules/@tanstack/query-core/build/lib/utils.mjs"],"sourcesContent":["// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}