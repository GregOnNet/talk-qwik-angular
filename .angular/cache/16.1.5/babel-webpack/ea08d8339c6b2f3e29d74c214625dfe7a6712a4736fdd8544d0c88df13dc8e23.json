{"ast":null,"code":"import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n  setOptions(options) {\n    var _this$currentMutation;\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$currentMutation2;\n      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);\n    }\n  }\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n    this.notify(notifyOptions);\n  }\n  getCurrentResult() {\n    return this.currentResult;\n  }\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n  mutate(variables, options) {\n    this.mutateOptions = options;\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n      if (options.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n}\nexport { MutationObserver };","map":{"version":3,"names":["getDefaultState","notifyManager","Subscribable","shallowEqualObjects","MutationObserver","constructor","client","options","setOptions","bindMethods","updateResult","mutate","bind","reset","_this$currentMutation","prevOptions","defaultMutationOptions","getMutationCache","notify","type","mutation","currentMutation","observer","onUnsubscribe","hasListeners","_this$currentMutation2","removeObserver","onMutationUpdate","action","notifyOptions","listeners","onSuccess","onError","getCurrentResult","currentResult","undefined","variables","mutateOptions","build","addObserver","execute","state","result","isLoading","status","isSuccess","isError","isIdle","batch","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","call","data","context","onSettled","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","error","forEach","listener"],"sources":["C:/Users/gregor.woiwode/workbench/talks/talk-qwik-angular/node_modules/.pnpm/@tanstack+query-core@4.32.0/node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs"],"sourcesContent":["import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    var _this$currentMutation;\n\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n\n    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$currentMutation2;\n\n      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\nexport { MutationObserver };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}